using System.Collections.Immutable;
using System.Linq;
using System.Text;
using CodeGenHelpers;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace ActivityMockGenerator;

[Generator]
public class ActivityMockCodeGenerator : IIncrementalGenerator
{
    // temporal constants
    private const string ActivityAttributeFullName = "Temporalio.Activities.ActivityAttribute";
    private const string TemporalActivitiesNamespace = "Temporalio.Activities";

    // NSubstitute constants
    private const string NSubstituteNamespace = "NSubstitute";
    
    // output constants
    private const string OutputNamespace = "Temporalio.Generators.Workflows";
    private const string OutputFileNameSuffix = "ActivityMock.g.cs";
    
    // attribute constants
    private const string AttributeName = "GenerateNSubstituteMocksAttribute";
    private const string BaseClassName = "ActivityMockBase";
    private const string AttributeOutputFileName = "ActivityMockCodeGeneratorAttribute.g.cs";
    private const string AttributeSourceCode = $$"""
                                                 // <auto-generated/>

                                                 namespace {{OutputNamespace}}
                                                 {
                                                     [System.AttributeUsage(System.AttributeTargets.Class)]
                                                     public class {{AttributeName}} : System.Attribute
                                                     {
                                                     }
                                                     
                                                     public abstract class {{BaseClassName}}<T> where T : class
                                                     {
                                                     }
                                                 }
                                                 """;
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Add the marker attribute to the compilation.
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            AttributeOutputFileName,
            SourceText.From(AttributeSourceCode, Encoding.UTF8)));
        
        var markedClasses = context.SyntaxProvider.ForAttributeWithMetadataName(
                $"{OutputNamespace}.{AttributeName}",
                predicate: static (s, _) => s is ClassDeclarationSyntax { AttributeLists.Count: > 0 },
                transform: static (ctx, _) => ctx.TargetSymbol as INamedTypeSymbol
            ).Where(static m => m is not null)
            .Collect();

        context.RegisterSourceOutput(markedClasses, Execute);
    }
    
    private static void Execute(SourceProductionContext context, ImmutableArray<INamedTypeSymbol?> symbols)
    {
        foreach (var namedTypeSymbol in symbols.Where(symbol => symbol is not null))
        {
            if (namedTypeSymbol is null)
            {
                continue;
            }
            
            // each class with its own namespace to match the target
            var builder = CodeBuilder.Create(namedTypeSymbol.ContainingNamespace)
                .AddNamespaceImport(NSubstituteNamespace)
                .AddNamespaceImport(TemporalActivitiesNamespace);

            // each mock class adds its own static class to the builder
            GenerateClassSource(builder, namedTypeSymbol);
            
            // each class outputs it own file
            context.AddSource(namedTypeSymbol.Name + OutputFileNameSuffix, builder.ToString());
        }

    }

    private static void GenerateClassSource(CodeBuilder builder, INamedTypeSymbol mockClass)
    {
        // ensure our symbol inherits the correct base class
        var baseType = mockClass.BaseType;
        if (baseType is not { Name: BaseClassName })
        {
            return;
        }
        
        // get the generic type argument which should be our target activity class
        var targetActivityClass = baseType.TypeArguments.FirstOrDefault();
        if (targetActivityClass is null)
        {
            return;
        }
        
        // add the class to the code builder
        var classBuilder = builder.AddClass(mockClass.Name)
            .MakePublicClass();
        
        // Collect all the activity methods on the target
        var activityMethods = targetActivityClass
            .GetMembers()
            .OfType<IMethodSymbol>()
            .Where(x => x.GetAttributes().Any(y => y.AttributeClass?.ToDisplayString() == ActivityAttributeFullName));

        foreach (var activitySymbol in activityMethods)
        {
            var methodParameters = activitySymbol.Parameters.Select(x => x.Type.ToDisplayString()).ToImmutableArray();
            var returnType = activitySymbol.ReturnType.ToDisplayString();

            // add a substitute delegate with the same signature as the target activity method
            //      in the format: Substitute.For<Func<...Parameters, ReturnType>>()
            var activityDelegateType =
                $"Func<{string.Join(", ", methodParameters)}{(methodParameters.Any() ? ", " : "")}{returnType}>";

            var mockPropertyName = $"Mock{activitySymbol.Name}";

            classBuilder
                .AddProperty(mockPropertyName, Accessibility.Public)
                .SetType(activityDelegateType)
                .WithValue($"Substitute.For<{activityDelegateType}>()");
            
            // add a method with the same name and signature as the activity that calls through to the substitute
            var methodBuilder = classBuilder
                .AddMethod(activitySymbol.Name, Accessibility.Public)
                .AddAttribute("Activity")
                .WithReturnType(activitySymbol.ReturnType.ToDisplayString())
                .WithBody(x =>
                    x.AppendLine(
                        $"return {mockPropertyName}({string.Join(", ", activitySymbol.Parameters.Select(param => param.Name))});"));
            
            // add all the required parameters to the method
            foreach (var parameter in activitySymbol.Parameters)
            {
                methodBuilder.AddParameter(parameter);
            }
        }
    }
}